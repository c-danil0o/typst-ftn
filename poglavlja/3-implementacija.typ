= Имплементација система
<implementacija>

Имплементација система GymMan представља кључни део овог рада, током којег су теоријски концепти и архитектонски принципи преточени у функционално софтверско решење. Процес развоја је вођен модуларним приступом, са циљем да се обезбеди јасна раздвојеност компоненти, лакше одржавање и будућа проширивост. Свака компонента система — десктоп апликација, мобилна апликација и пратећа инфраструктура у облаку — развијена је са специфичним технологијама које најбоље одговарају њеној намени, али су све повезане кроз заједнички модел података и пажљиво дефинисане комуникационе протоколе.

У овом поглављу биће детаљно описан процес имплементације сваке од наведених компоненти. Акценат ће бити на техничким одлукама, изабраним библиотекама и програмским језицима, као и на примерима кода који илуструју
битне механизме система.

== Имплементација десктоп апликације

Десктоп апликација представља централну компоненту система GymMan, осмишљену као главни алат за администраторе и радници у фитнес центру. За њену израду изабран је радни оквир
#link("https://tauri.app/")[Tauri], који омогућава развој вишеплатформских (енгл. _cross-platform_) апликација комбиновањем перформанси и сигурности програмског језика Rust са флексибилношћу модерних веб технологија за
израду корисничког интерфејса. У поређењу са алтернативама као што је Electron, Tauri нуди значајне предности у виду мање потрошње меморије, мање величине финалне апликације и директнијег приступа
системским ресурсима, што га је учинило идеалним избором за овај пројекат @tauri@electron-tauri.

Архитектура десктоп апликације подељена је на две основне целине: позадински део (енгл. _backend_) реализован у Rust-у и кориснички интерфејс (енгл. _frontend_) реализован помоћу #link("https://svelte.dev/")[Svelte] оквира.

== Имплементација позадинске логике (Rust)

Позадински део апликације, смештен у директоријуму `src-tauri`, представља њену основу и одговоран је за сву пословну логику, управљање подацима и комуникацију са спољним системима. Као програмски језик изабран
је Rust због својих гаранција сигурности меморије, високих перформанси и одличног екосистема за конкурентно програмирање, што је од великог значаја за асинхроне задатке попут синхронизације и прављења резервних копија.

=== Структура и управљање стањем

Основна структура позадинског дела организована је у модуле који одговарају различитим доменима апликације: `commands` (командни интерфејс), `db` (управљање базом), `sync` (логика синхронизације), `backup` (резервне копије),  `models` (модели података), `dto` (типови за пренос података према корисничком интерфејсу).

Централно стање апликације (енгл. _state_) дефинисано је у структури `AppState`, која се иницијализује приликом покретања и дели између свих компоненти путем Tauri механизма за управљање стањем. Ова структура садржи групу отворених конекција према бази података (енгл. _connection pool_), као и конфигурациона подешавања апликације.

```rust
pub struct AppState {
    pub db_pool: SqlitePool,
    pub settings: RwLock<AppSettings>,
    pub last_membership_check: RwLock<Option<chrono::NaiveDateTime>>,
    pub last_backup: RwLock<Option<chrono::NaiveDateTime>>,
    pub sync_mutex: Mutex<()>,
    pub supabase_client: RwLock<Option<SupabaseClient>>,
}
```
=== Командни интерфејс

Комуникација између фронтенда и бекенда реализована је преко Tauri командног интерфејса. Свака функција у Rust-у која треба да буде доступна из JavaScript-а
означена је са `#[tauri::command]`. Ове функције су асинхроне и враћају `AppResult` тип, што омогућава елегантно руковање грешкама које се затим прослеђују фронтенду.
`AppResult` је дефинисан као `pub type Result<T> = std::result::Result<T, AppError>`, где се у случају грешке враћа прилагођени `AppError` тип који садржи детаље о специфичном проблему.

Пример команде за обраду скенирања картице:
```rust
#[tauri::command]
pub async fn process_scan(
    payload: ScanPayload,
    app_state: tauri::State<'_, AppState>
) -> Result<ScanProcessingResult, String> {
    // 1. Проналажење члана у локалној бази
    // 2. Валидација чланарине
    // 3. Ажурирање броја посета
    // 4. Упис у евиденцију улазака (entry_log)
    // 5. Враћање резултата фронтенду
    // ...
    Ok(result)
}
```
Овај приступ елиминише потребу за интерним HTTP (енгл. Hyper-Text-Transfer-Protocol) сервером и омогућава брзу и сигурну комуникацију између два дела апликације.

=== Управљање базом података и миграције

За интеракцију са SQLite @sqlite базом података користи се библиотека #link("https://github.com/launchbadge/sqlx")[SQLx], која пружа типски безбедне (енгл. _type-safe_) SQL упите верификоване током компајлирања.
Ово значајно смањује могућност грешака у раду са базом.

Структура базе података дефинисана је кроз скуп SQL миграционих фајлова, којима управља `sqlx-cli`. Приликом првог покретања апликације, Rust код аутоматски извршава све потребне миграције како би креирао или ажурирао локалну базу на најновију верзију, што осигурава конзистентност шеме.

Подаци се уписују и читају коришћењем асинхроних метода које пружа SQLx, чиме се избегава блокирање главног програмског тока и корисничког интерфејса током операција са базом.

=== Асинхрони задаци у позадини

Систем користи асинхрони #link("https://tokio.rs/")[Tokio] _runtime_ за извршавање дуготрајних задатака у позадини, независно од главног UI тока. Кључни позадински процеси су:

- _Sync Worker_: Периодично (нпр. на сваких 30 секунди) проверава pending_changes табелу и шаље нове промене на Supabase.

- _Backup Scheduler_: Покреће процес прављења резервне копије у конфигурисаним временским интервалима.

- _Membership Status Checker_: Једном дневно  проверава и ажурира статусе чланарина (нпр. из "pending" у "active" или из "active" у "expired") како би систем проактивно увек имао ажурне статусе чланарина.

Ови задаци се покрећу приликом стартовања апликације као засебни асинхрони задаци, користећи `tokio::spawn` @tokio.
Сви процеси се логују у структурисаном формату користећи библиотеку `tracing`.

=== Конфигурација и чување подешавања

Подешавања апликације као што су _Supabase_ API кључ, сервер резервних копија, интервал синхронизације и избор језика поставља админстратор и она се чувају се у посебном JSON фајлу (`app_settings.json`) у апликационом директоријуму добијеном преко `tauri::api::path::app_data_dir()` @tauripath.
Овим се обезбеђује да подаци остану перзистентни и након рестартовања апликације.

=== Дистрибуција и аутоматско ажурирање апликације

Како би се корисницима омогућило једноставно преузимање и редовно ажурирање апликације, систем GymMan користи аутоматизоване процесе за израду, објављивање и дистрибуцију нових верзија. Овај приступ осигурава да сваки корисник увек има приступ најновијим функционалностима и сигурносним исправкама уз минималан напор.

==== Аутоматизована израда на GitHub платформи

Процес објављивања нових верзија је у потпуности аутоматизован помоћу GitHub Actions @githubactions. Сваки пут када се на репозиторијум постави нови "tag" (нпр. `v1.0.1`), аутоматски се покреће процес који:
1.  Компајлира апликацију: За сваку циљну платформу (Windows, Linux) креира се одговарајући инсталациони пакет (`.msi`, `.deb`, `.AppImage`).
2.  Дигитално потписује пакет: Користећи сигурносни кључ сачуван у GitHub Secrets @githubactions, сваки инсталациони пакет добија дигитални потпис (`.sig` фајл). Овај потпис гарантује да ажурирање долази од аутентичног извора и да није мењано.
3.  Генерише `latest.json` манифест: Кључни корак у овом процесу је аутоматско генерисање `latest.json` датотеке. Акција `tauri-action` унутар радног тока (енгл. _workflow_) прикупља информације о новој верзији,
    белешке о издању (енгл. `release notes`), и што је најважније, URL-ове до свих инсталационих пакета и садржај свих `.sig` датотека. Све ове информације се пакују у `latest.json` датотеку, која служи као _update manifest_.
4.  Објављује на GitHub Releases: На крају, сви пакети, њихови потписи, и генерисани `latest.json` фајл се аутоматски објављују као артефакти у оквиру новог издања (енгл. _release_) на GitHub-у.

Ова континуирана интеграција и испорука (CI/CD, енгл. _Continuous Integration and Continuous Delivery_) елиминише ручни рад, смањује могућност грешке и убрзава испоруку нових верзија.

==== Механизам за аутоматско ажурирање

Десктоп апликација има уграђен механизам за аутоматско ажурирање, реализован помоћу `tauri-plugin-updater` плагина. Конфигурација овог плагина у `tauri.conf.json` фајлу је подешена да директно комуницира са провајдером издања на GitHub-у.
```json
"plugins": {
  "updater": {
    "active": true,
    "endpoints": [
      "https://github.com/c-danil0o/gym_manager/releases/latest/download/latest.json"
    ],
    "pubkey": "...",
    "dialog": true
  }
}
```
Овај механизам омогућава апликацији да провери `latest.json` фајл на GitHub-у и провери да ли постоје нове верзије. Када се открије нова верзија, апликација преузима одговарајући инсталациони пакет и његов дигитални потпис.
Инсталација нове верзије се изводи само након успешне верификације дигиталног потписа, чиме се обезбеђује сигурност и интегритет ажурирања.


== Имплементација корисничког интерфејса (SvelteKit)

Кориснички интерфејс (фронтенд) десктоп апликације представља компоненту са којом корисници (администратори и радници) директно интерагују. За његову реализацију изабран је #link("https://kit.svelte.dev/")[SvelteKit],
савремени радни оквир за израду веб апликација базиран на другом радном оквиру под именом Svelte. Кључна предност Svelte-а лежи у његовом компајлерском приступу: уместо да се ослања на виртуелни објектни модел документа (DOM, енгл. _Document Object Model_), Svelte компајлира компоненте у оптималан,
императивни JavaScript код који директно манипулише DOM-ом @svelte. Ово резултира изузетно брзим апликацијама са минималним додатним трошком у смислу перформанси (енгл. _overhead_), што га чини идеалним за ресурсно ефикасне десктоп апликације попут оних које се
праве са Tauri радним оквиром. Интерфејс је имплементиран да буде потпуно прилагодљив величини прозора, омогућавајући рад на различитим уређајима и резолуцијама.

=== Архитектура и организација кода

Пројектна структура фронтенда прати конвенције SvelteKit-а и организована је на начин који подржава модуларност и лаку навигацију:
- `src/routes/`: Овај директоријум садржи структуру свих страница и рута у апликацији. SvelteKit користи _file-system based routing_, где структура фајлова директно одговара URL путањама. На пример, фајл `src/routes/members/[id]/+page.svelte` дефинише страницу за приказ детаља појединачног члана.
- `src/lib/`: Централни директоријум за сав дељени код.
  - `src/lib/components/`: Садржи Svelte компоненте као што су форме, табеле, дијалози, графикони и дугмад.
  - `src/lib/stores/`: Дефинише глобално стање апликације коришћењем Svelte _stores_. Овде се чувају подаци о улогованом кориснику, статусу синхронизације, изабраној теми (светла/тамна) и језику.
  - `src/lib/models/`: Садржи TypeScript типове који су аутоматски који одговарају типовима за пренос података (DTO, енгл. Data-Transfer-Object) дефинисаним у Rust позадинском делу. Ово обезбеђује типску безбедност приликом комуникације између фронтенда и бекенда.
  - `src/lib/paraglide/`: Директоријум који садржи превоце за интернационализацију.

=== Комуникација са позадинском логиком

Интеракција између фронтенда (JavaScript/TypeScript) и бекенда (Rust) је кључни аспект Tauri апликације. Ова комуникација се одвија асинхроно преко Tauri командног интерфејса, коришћењем `invoke` функције из `@tauri-apps/api` пакета. Свака `#[tauri::command]` функција у Rust-у је директно доступна за позивање, чиме се елиминише потреба за традиционалним REST или GraphQL API-јем.

Пример имплементације позива командe за додавање новог члана:

```ts
import { invoke } from '@tauri-apps/api/core';
import type { MemberPayload } from '$lib/models'; // Типови из Rust-а

async function saveNewMember(memberData: MemberPayload): Promise<void> {
  try {
    // Позив Tauri команде
    await invoke('save_member', { payload: memberData });
    // Потврда успешног чувања
  } catch (error) {
    // Приказ грешке
    console.error('Failed to save member:', error);
  }
```

=== Управљање стањем и реактивност

За управљање стањем апликације користи се уграђени систем Svelte _stores_. Овај приступ је једноставан, али изузетно моћан. На пример, _writable store_ се користи за чување информација о тренутно улогованом кориснику, што омогућава да се делови интерфејса динамички приказују или сакривају у зависности од његове улоге (администратор или радник).

Svelte реактивност осигурава да се свака промена у _store_-у аутоматски пропагира кроз све компоненте које га користе, што резултира тренутним ажурирањем корисничког интерфејса без потребе за ручном манипулацијом.
Пример једноставног _store_-а за тренутног корисника:
```ts
import { writable } from 'svelte/store';

const { subscribe, set, update } = writable({
		isAuthenticated: false,
		username: null as string | null,
		error: null as string | null,
		role: null as string | null
	});
```

Поред тога, апликација користи _Tauri events_ за реактивност на промене инициране из бекенда. На пример, када позадински процес прими резултат асинхроне синхронизације података, он емитује догађај `sync_status_changed`. Фронтенд слуша овај догађај и аутоматски освежава приказ статуса.

```ts
import { listen } from '@tauri-apps/api/event';

// Слушање догађаја из бекенда
const unlisten = await listen('sync_status_changed', (event) => {
  console.log('Sync status changed. Refreshing data...', event.payload);
  refreshStatus();
});
```

=== Стилизовање и кориснички интерфејс

Стилизовање апликације урађено је помоћу #link("https://tailwindcss.com/")[Tailwind CSS]. За сложеније UI елементе као што су модални дијалози, табеле са пагинацијом и сортирањем, и падајуће листе, коришћена је библиотека #link("https://www.shadcn-svelte.com/")[shadcn-svelte]. Ова библиотека представља регистар прилагодљивих и приступачних (енгл. accessible) компоненти које се лако интегришу и модификују. Компоненте се инталирају појединачно, што омогућава минималну величину пакета и боље перформансе.

Апликација такође подржава светлу и тамну тему. Ова функционалност је имплементирана коришћењем CSS варијабли, а промена теме се врши преко `mode-watcher` компоненте која детектује системска подешавања или омогућава кориснику ручни избор.

=== Валидација форми и обрада грешака

За валидацију корисничког уноса у формама користи се библиотека #link("https://zod.dev/")[Zod] за дефинисање шема података и правила валидације, у комбинацији са #link("https://superforms.rocks/")[Superforms] библиотеком
за SvelteKit. Ова комбинација омогућава:
- Типски сигурну дефиницију форми.
- Валидацију у реалном времену, док корисник уноси податке.
- Јасно приказивање грешака испод одговарајућих поља.
- Спречавање слања неисправних података на бекенд.

Грешке које стигну са бекенда (нпр. грешка при упису у базу) се хватају у _try-catch_ блоковима, преводе се и затим приказују кориснику путем _toast_ нотификација, пружајући јасну повратну информацију о исходу операције.

=== Интернационализација (i18n)

Подршка за више језика (српски, енглески) реализована је помоћу #link("https://inlang.com/m/gerre34r/library-paraglide-js")[ParaglideJS]. Овај алат компајлира преводе из JSON фајлова у типски сигурне
TypeScript модуле, чиме се елиминише могућност грешака услед недостајућих превода или погрешних кључева.

Пример коришћења превода у Svelte компонентама:
```ts
import * as m from '$lib/paraglide/messages';
// ...
<button>{m.loginButtonLabel()}</button>
```

== Имплементација инфраструктуре у облаку

Иако је GymMan систем дизајниран са _offline-first_ архитектуром као основном премисом, инфраструктура у облаку (енгл. _cloud_) игра важну, двоструку улогу у његовом функционисању. Прва улога је обезбеђивање сигурног и
поузданог механизма за прављење резервних копија (енгл. _backup_) комплетне локалне базе података, што је битно за очување података у случају хардверског квара или других непредвиђених догађаја.
Друга улога је подршка за опциони онлајн (енгл. _online_) режим рада, где се подаци асинхроно синхронизују са централном базом како би се омогућила функционалност мобилне апликације.

За реализацију ове две различите потребе, изабране су две одвојене _cloud_ платформе, свака оптимизована за свој задатак. За систем резервних копија коришћени су сервиси #link("https://aws.amazon.com/")[Amazon Web Services (AWS)
], док је за синхронизацију података и подршку за мобилну апликацију изабрана #link("https://supabase.com/")[Supabase] платформа. У наставку ће бити детаљно описана архитектура и имплементација оба система.

=== Систем за резервне копије на AWS платформи

Циљ система за резервне копије је да омогући кориснику да, на захтев или аутоматски, сачува комплетну SQLite базу података на сигурну и удаљену локацију.
Овај процес мора бити безбедан, ефикасан и једноставан за конфигурацију са корисничке стране. Изабрана је _serverless_ архитектура на AWS-у, која елиминише потребу за одржавањем сервера и нуди
високу скалабилност и поузданост уз плаћање по потрошњи (енгл. _pay-as-you-go_).

==== Архитектура AWS сервиса

Систем се састоји од четири AWS сервиса који раде заједно:
1.  *Amazon S3 (Simple Storage Service)*: Користи се као складиште за чување компресованих `.sqlite` фајлова. Сваки корисник (теретана) добија јединствени сигурни токен, који се користи као префикс ("фолдер") унутар S3
  _bucket_-а, чиме се подаци различитих корисника строго изолују. За _bucket_ је конфигурисанo верзионисање и правила која аутоматски бришу старе верзије резервних копија (нпр. чувају се само последње три),
  оптимизујући трошкове складиштења.

2.  *AWS Lambda*: Представља _serverless_ рачунарску платформу. Имплементиране су три одвојене Lambda функције написане у програмском језику Python, свака са специфичном наменом:
    - `upload-backup`: Прихвата `POST` захтев са компримованим фајлом, верификује аутентикациони токен и смешта фајл у одговарајући S3 префикс.
    - `download-backup`: Прихвата `GET` захтев, верификује токен и омогућава преузимање одређене верзије резервне копије.
    - `list-versions`: Прихвата `GET` захтев, верификује токен и враћа листу доступних верзија резервних копија са метаподацима (датум, величина).

3.  *Amazon API Gateway*: Служи као сигуран и управљив улазни _endpoint_ за Lambda функције. Он претвара HTTP захтеве (нпр. `POST /backup/{token}`) у догађаје који покрећу одговарајућу Lambda функцију. Конфигурисан је да рукује бинарним подацима (`application/octet-stream`), примењује CORS правила и прослеђује параметре путање (као што је токен) Lambda функцијама.

4.  *AWS IAM (Identity and Access Management)*: Користи се за дефинисање прецизних дозвола. Креирана је посебна IAM улога за Lambda функције која им даје минималне потребне привилегије: дозволу за упис и читање објеката унутар S3 _bucket_-а и дозволу за упис логова у Amazon CloudWatch.

==== Процес слања и враћања резервне копије

Процес са стране десктоп апликације (Rust бекенд) је следећи:

1.  Креирање резервне копије: На захтев корисника, апликација користи `VACUUM INTO` SQL команду да креира конзистентну слику (енгл. _snapshot_) локалне SQLite базе у привремени фајл. Овај приступ је сигуран за коришћење док апликација ради, јер исправно рукује WAL (_Write-Ahead Logging_) режимом.

2.  Слање на API: Привремени фајл се чита у меморију, а затим се шаље као бинарни податак путем `POST` HTTP захтева на API Gateway _endpoint_. Захтев у заглављу (енгл. _header_) садржи и сигурносни токен који аутентификује клијента.

3.  Враћање података (Restore): Процес враћања је вишефазни како би се осигурао интегритет података. Прво се преузима листа доступних верзија. Након што корисник одабере верзију, апликација преузима компримовани фајл, проверава његов интегритет, затвара конекцију ка локалној бази, брише старе `.sqlite-wal` и `.sqlite-shm` фајлове, и тек онда замењује главни `.sqlite` фајл са преузетим.

==== Конфигурација са корисничке стране

Да би систем био флексибилан, корисник (власник теретане) у подешавањима апликације уноси јединствени URL за резервну копију. Овај URL садржи _endpoint_ и сигурносни токен, форматиран на следећи начин:
```url
https://<api_gateway_id>.execute-api.<region>.amazonaws.com/prod#<backup_token>
```
Апликација парсира овај URL како би добила базни URL за API позиве и токен за аутентификацију. Токен се генерише приликом првог покретања апликације као јединствени UUID и приказује се кориснику. Уколико корисник жели да користи исту резервну копију на другом рачунару (пренесе систем на други рачунар), потребно је само да унесе исти URL.

=== _Online_ режим и синхронизација са Supabase платформом

_Оnline_ режим представља сложену архитектуру која омогућава континуирану синхронизацију података и функционалност мобилне апликације. За ову сврху, изабрана је Supabase платформа због своје интегрисане понуде која укључује PostgreSQL базу, систем за аутентификацију и аутоматски генерисан PostgREST API @postgrest@supabase.

==== Архитектура Supabase сервиса

1.  *PostgreSQL база података*: Централна база података чија шема одражава поједностављену структуру локалне SQLite базе. Иако је могуће, формалне _foreign key_ релације нису дефинисане, како би се поједноставила
    логика _upsert_ (комбинација _update_ и _insert_) операција из _Sync Worker_-а. Превод између SQLite и PostgreSQL дијалеката се обавља у самом синхронизационом процесу.

2.  *Supabase Auth*: Користи се као систем за управљање идентитетима за кориснике мобилне апликације. Он рукује регистрацијом (путем позивног линка), пријавом (користећи email и лозинку) и издавањем
    JWT (_JSON Web Tokens_) токена који служе за аутентификацију API захтева.

3.  *PostgREST API*: Supabase аутоматски излаже RESTful API преко свих табела у `public` шеми. Овај API је главни канал комуникације за _Sync Worker_ из десктоп апликације.
    API подржава сложене упите, филтрирање и _upsert_ операције.

4.  *Функције базе података (RPC)*: За сложеније упите, као што је проналажење "најрелевантније" чланарине за корисника, креирана је PostgreSQL функција (`get_my_relevant_membership`). Ова функција енкапсулира комплексну
    SQL логику на серверу и изложена је као један RPC _endpoint_, што значајно поједностављује код на мобилном клијенту.

5.  *Row-Level Security (RLS)*: Ово је кључни сигурносни механизам. На свим табелама којима приступа мобилна апликација активиран је RLS. Дефинисане су полисе које користе `auth.uid()` функцију како би
    осигурале да сваки улоговани корисник може да чита *искључиво* податке који су повезани са његовим налогом. Ово ефикасно спречава неовлашћен приступ подацима других корисника.

==== Процес синхронизације

Процес је дизајниран да буде отпоран на грешке и прекиде у конекцији.

1.  Хватање промена: Свака `INSERT`, `UPDATE` или `DELETE` операција у локалној SQLite бази над праћеним табелама, путем SQL тригера, аутоматски креира запис у `pending_changes` табели.
    Овај запис садржи све информације потребне за репликацију операције (назив табеле, тип операције, ID записа и JSON пакет (енгл. _payload_) са новим подацима).

2.  Слање промена: _Sync Worker_ у Rust бекенду периодично преузима групу (енгл. _batch_) записа из `pending_changes` са статусом _pending_.

3.  "Claim-then-process" механизам: Да би се спречило да више _worker_-а обрађује исти запис, _worker_ прво атомски ажурира статус записа у _processing_. Тек након тога шаље податке на Supabase PostgREST API.

4.  Руковање грешкама: Уколико слање не успе, _worker_ ажурира запис у `pending_changes`, повећава бројач покушаја (`attempts`) и уписује поруку о грешци. Након одређеног броја неуспешних покушаја,
    запис се означава као _failed_ и изузима из даље обраде, како не би блокирао остатак реда. Уколико је слање успешно, запис се брише из `pending_changes` табеле.

Овај шаблон осигурава да се ниједна промена не изгуби и да систем може наставити са радом чак и након дужих периода без интернет конекције.

== Имплементација мобилне апликације

Мобилна апликација представља битну тачку интеракције између фитнес центра и његових чланова, пружајући им дигитални алат који замењује физичку чланску картицу и нуди тренутни увид у статус њиховог чланства.
За развој је изабран #link("https://flutter.dev/")[Flutter] радни оквир компаније Google, који омогућава креирање нативних апликација за Android и iOS платформе у програмском језику Dart.
Овај избор доноси значајне предности у виду бржег развоја, конзистентног корисничког искуства на обе платформе и приступа богатом екосистему готових компоненти @flutter-comp.

Апликација је свесно дизајнирана да буде једноставна, брза и фокусирана на две основне функције: приказ дигиталне чланске картице у виду бар-кода и преглед детаља о тренутној или предстојећој чланарини.
Сва комуникација са позадинским системом одвија се директно са Supabase платформом.

=== Архитектура и организација кода

Архитектура мобилне апликације је постављена тако да је код организован у директоријуме који одговарају функционалним целинама. Овакав приступ олакшава навигацију и одржавање кода.

```
lib/
├── api/
│ └── supabase_service.dart # Сва комуникација са Supabase API-јем
├── auth/
│ ├── auth_repository.dart # Логика за пријаву и одјаву
│ └── login_page.dart # UI за страницу за пријаву
├── core/
│ ├── models/ # Модели података (Member, Membership)
│ └── widgets/ # UI компоненте
├── home/
│ ├── home_page.dart # Главни екран са табовима
│ ├── barcode_tab.dart # UI за приказ бар-кода
│ └── membership_tab.dart # UI за приказ детаља чланарине
├── main.dart # Улазна тачка апликације
└── splash_page.dart # Екран за проверу аутентификације
```
Ова структура јасно одваја слој за приступ подацима (`api`), слој за аутентификацију (`auth`), дељене ресурсе (`core`) и главне функционалности апликације (`home`).

=== Управљање аутентификацијом и сесијом

Аутентификација корисника се у потпуности ослања на Supabase Auth. Процес је дизајниран да буде сигуран и да пружи беспрекорно корисничко искуство.

1.  *Пријава*: Корисник уноси своју е-пошту и лозинку (коју је претходно поставио преко веб странице). Апликација позива `supabase.auth.signInWithPassword()` метод.
2.  *Управљање сесијом*: Након успешне пријаве, `supabase-flutter` библиотека аутоматски безбедно складишти добијени JWT токен (сесију) на уређају (`SharedPreferences` на Android-у, `NSUserDefaults` на iOS-у).
3.  *Аутоматско освежавање токена*: Библиотека такође аутоматски рукује освежавањем краткотрајних _access_ токена користећи дуготрајни _refresh_ токен. Ово значи да ће корисник остати улогован недељама или месецима, све док не изабере опцију за одјаву, што је очекивано понашање за модерне мобилне апликације.
4.  *Реактивност на стање сесије*: Улазна тачка апликације (`main.dart`) користи `StreamBuilder` који слуша `supabase.auth.onAuthStateChange` ток. Овај механизам омогућава да се кориснички интерфејс аутоматски мења у зависности од тога да ли је корисник улогован или не, елегантно пребацујући између `LoginPage` и `HomePage` без икакве ручне логике.

Пример `StreamBuilder`-а у `main.dart`:
```dart
home: StreamBuilder<AuthState>(
  stream: supabase.auth.onAuthStateChange,
  builder: (context, snapshot) {
    if (snapshot.hasData && snapshot.data?.session != null) {
      return const HomePage(); // Корисник је улогован
    }
    return const LoginPage(); // Корисник није улогован
  },
),
```
=== Приступ подацима и сигурност

Како мобилна апликација ради у несигурном окружењу (на уређају корисника), приступ подацима је ригорозно контролисан.

- Коришћење _anon_ кључа: Апликација се повезује на Supabase користећи јавни, _anonymous_ кључ. Овај кључ сам по себи не даје никакве дозволе за читање података.
- Row-Level Security (RLS): Приступ подацима је омогућен искључиво кроз RLS полисе дефинисане на PostgreSQL бази. Свака полиса користи `auth.uid()` функцију да идентификује
  улогованог корисника и дозволи му приступ само оним редовима у табелама који су директно повезани са његовим налогом. Ово је темељ сигурности апликације.
- Позивање RPC функције: Уместо да апликација прави сложене упите, она позива једну, претходно дефинисану базу података функцију `get_my_relevant_membership`. Ова функција на серверу извршава сву
  потребну логику (укључујући JOIN са другим табелама) и враћа само минимални скуп података потребан за приказ. Овај приступ је ефикасан и додатно побољшава сигурност јер је логика енкапсулирана на серверу.

Пример позива RPC функције из _SupabaseService_:
```dart
final membershipResponse = await _supabase
    .rpc('get_my_relevant_membership')
    .single();

final membership = Membership.fromJson(membershipResponse);
```
=== Кориснички интерфејс и искуство

Кориснички интерфејс је изграђен коришћењем Flutter декларативног модела и скупа _Material Design_ компоненти. Главни екран (_HomePage_) користи `BottomNavigationBar` за лаку навигацију између два главна таба:
"Картица" и "Чланарина".
- Таб "Картица": Овај екран има централну улогу. Након што се подаци учитају, приказује јасан и велики бар-код генерисан помоћу `barcode_widget` пакета.
- Таб "Чланарина": Овај екран приказује детаље о чланарини на структуриран начин, користећи низ "картица" за сваку информацију (статус, датум почетка, датум истека, преостале посете)
Асинхроно учитавање података: Оба таба користе `FutureBuilder` виџет. Ово омогућава да се приликом учитавања података са мреже прикаже индикатор учитавања (енгл. _loading spinner_), а у случају грешке, јасна порука кориснику. Ово спречава "замрзавање" интерфејса и побољшава корисничко искуство.

=== Интернационализација (i18n)

Апликација је од почетка дизајнирана да подржава више језика. Коришћен је уграђени `flutter_localizations` систем. Сви текстови видљиви кориснику су издвојени у .arb (_Application Resource Bundle_) фајлове за сваки
подржани језик (енглески, српски). Flutter аутоматски бира одговарајући језик на основу подешавања на телефону корисника, чинећи апликацију доступном широј публици.

=== Дистрибуција

Апликација се гради у оптимизовани, потписани бинарни фајл спреман за дистрибуцију.
- За Android, генерише се _Android App Bundle_ (.aab) фајл, који је стандард за објављивање на Google Play продавници.
- За iOS, процес израде се врши кроз Xcode, што је предуслов за дистрибуцију на Apple App Store.

== Имплементација веб апликације за управљање лозинком

Веб апликација за управљање лозинком још једну једноставну компоненту GymMan система. Њена основна улога је да послужи као сигуран повезник између позива који члан добије путем е-поште и његовог успешног активирања налога за мобилну апликацију. Ова компонента решава два кључна сценарија:

1.  *Постављање иницијалне лозинке*: Када администратор у десктоп апликацији позове новог члана, Supabase Auth шаље е-поруку са јединственим _magic link_-ом.
    Кликом на тај линк, корисник долази на ову веб страницу како би дефинисао своју лозинку по први пут.
2.  *Ресетовање заборављене лозинке*: Уколико члан заборави своју лозинку, од радника у теретани може затражити процес ресетовања лозинке. Ова опција покреће слање е-поруке за ресетовање,
    која га такође усмерава на ову исту веб страницу.

Избор да се ова функционалност реализује као веб апликација, а не унутар саме мобилне апликације, је стратешки. Веб линкови су универзални и функционишу на свим уређајима, без обзира да ли корисник
има већ инсталирану мобилну апликацију или не. Ово значајно поједностављује процес иницијалне регистрације. Веб апликација је потпуно прилагођена мобилним уређајима,
осигуравајући несметано функционисање када се приступа преко телефона.

=== Технологије и хостинг

За развој веб апликације изабран је #link("https://kit.svelte.dev/")[SvelteKit], исти радни оквир који се користи и за фронтенд десктоп апликације. За хостинг је изабрана #link("https://www.netlify.com/")[Netlify] платформа.

Netlify је изабран због своје једноставности, бесплатног _tier_-а за мање пројекте и одличне интеграције са Git-ом, што омогућава континуирану испоруку (енгл. _Continuous Deployment_) @netlify.
Свака промена на главној грани репозиторијума аутоматски покреће процес израде и објављивања нове верзије сајта.

=== Процес постављања и ресетовања лозинке

Процес је дизајниран да буде што једноставнији за корисника, док се у позадини одвија сигуран протокол за аутентификацију који диктира Supabase Auth.

1. Покретање процеса регистрације или ресетовања лозинке: Радник у теретани иницира позив новог члана или процес ресетовања лозинке преко десктоп апликације.
   Supabase Auth шаље е-поруку са јединственим линком који садржи `access_token`.

2.  Долазак на страницу: Корисник кликне на линк у својој е-поруци. Тај линк садржи _URL fragment_ (део URL-а након `#`) у којем се налази `access_token` који је генерисао Supabase.
    Пример URL-а: `https://gymman-set-password.netlify.app/#access_token=...&token_type=bearer&...`

3.  Аутоматска обрада токена: Након што се страница учита у прегледачу, `supabase-js` библиотека (клијент за Supabase на фронтенду) аутоматски детектује овај _URL fragment_. Она користи добијени `access_token` да
    покрене привремену, аутентификовану сесију за корисника. У овом тренутку, иако корисник још није унео лозинку, он је за Supabase систем "улогован".

4.  Унос нове лозинке: Кориснички интерфејс приказује једноставну форму са пољем за унос нове лозинке и дугметом за потврду.

5.  Ажурирање корисничког налога: Када корисник унесе и потврди лозинку, апликација позива `supabase.auth.updateUser()` метод, прослеђујући нову лозинку.
    ```javascript
    async function handleSetPassword(newPassword) {
      const { data, error } = await supabase.auth.updateUser({
        password: newPassword
      });
    }
    ```
    Пошто је корисник у привременој сесији (из корака 2), Supabase Auth зна за који налог треба да ажурира лозинку. Овај позив је сигуран јер је ауторизован `access_token`-ом из URL-а.

6.  Завршетак процеса: Након успешног ажурирања, сесија се уништава, а кориснику се приказује порука која га упућује да преузме моблину апликацију и да се пријави користећи своју е-пошту и нову лозинку.

=== Интеграција са сервисом за слање е-поште (Resend)

Иако Supabase има уграђен систем за слање е-поште, он има одређена ограничења у погледу броја послатих порука и могућности прилагођавања. Да би се обезбедила већа поузданост и бољи _deliverability_
(способност да мејлови не заврше у _spam_ фолдеру), систем је конфигурисан да користи спољни SMTP сервис. За ову сврху изабран је #link("https://resend.com/")[Resend] сервис за е-поруке.
